import {drive_v3 as driveV3, docs_v1 as docsV1} from 'googleapis'
import {Stream} from 'stream'
import {CustomerInfo} from '../../utils/customerInfo'
import {Blueprint} from '../../../constants/models/Blueprint'
import sendMail from '../../utils/sendMail'

// const TEMP_FOLDER: string = String(process.env.TEMP_FOLDER)

export interface Tokens {
	accessToken?: string
	refreshToken?: string
}

async function copyFile({
	sourceId,
	name,
	targetFolderId,
	drive,
}: {
	sourceId: string
	name: string
	targetFolderId: string
	drive: driveV3.Drive
}): Promise<string> {
	const result = await drive.files.copy({
		fileId: sourceId,
		requestBody: {
			name,
			parents: [targetFolderId],
		},
	})

	return result.data.id || '0'
}

export async function canUserRead({
	fileId,
	drive,
}: {
	fileId: string
	drive: driveV3.Drive
}): Promise<boolean> {
	try {
		await drive.files.get({fileId})
		return true
	} catch (e) {
		return false
	}
}

async function replaceTemplateStrings({
	documentId,
	keyMap,
	docs,
}: {
	documentId: string
	keyMap: any
	docs: docsV1.Docs
}) {
	const replaceTextRequests = Object.keys(keyMap).map((key) => {
		return {
			replaceAllText: {
				containsText: {text: `{{${key}}}`, matchCase: true},
				replaceText: keyMap[key],
			},
		}
	})

	await docs.documents.batchUpdate({
		documentId,
		requestBody: {
			requests: replaceTextRequests,
		},
	})
}

export async function generateFilledDocument({
	blueprint,
	targetFolderId,
	fileName,
	values,
	drive,
	docs,
}: {
	blueprint: Blueprint
	fileName: string
	values: any
	targetFolderId: string
	drive: driveV3.Drive
	docs: docsV1.Docs
}): Promise<string> {
	const createdFileId = await copyFile({
		drive,
		name: fileName,
		sourceId: blueprint.googleDocsId,
		targetFolderId,
	})

	await replaceTemplateStrings({
		documentId: createdFileId,
		docs,
		keyMap: values,
	})

	return createdFileId
}

export async function saveDocumentAsPdf({
	name,
	fileId,
	folderId,
	drive,
}: {
	name: string
	fileId: string
	folderId: string
	drive: driveV3.Drive
}): Promise<string> {
	const exportResponse = await drive.files.export(
		{
			fileId,
			mimeType: 'application/pdf',
		},
		{
			responseType: 'stream',
		}
	)
	// @ts-ignore
	const outputStream: Stream = exportResponse.data

	const creatResponse = await drive.files.create({
		media: {
			mimeType: 'application/pdf',
			body: outputStream,
		},
		requestBody: {
			name,
			mimeType: 'application/pdf',
			parents: [folderId],
		},
	})

	return creatResponse.data.id || '0'
}

export async function getFolderInfo({
	folderId,
	drive,
}: {
	folderId: string
	drive: driveV3.Drive
}) {
	try {
		const exportResponse = await drive.files.get({
			fileId: folderId,
		})
		const {id, name} = exportResponse.data
		return {id, name}
	} catch (e) {
		return null
	}
}

export async function silentlyDeleteFile({
	fileId,
	drive,
}: {
	fileId: string
	drive: driveV3.Drive
}) {
	console.log('removing file', {fileId})
	try {
		await drive.files.delete({
			fileId,
		})
	} catch (e) {
		// Fail silently
	}
}

// export async function shareWithUser({
// 	fileId,
// 	userEmail,
// 	drive,
// }: {
// 	fileId: string
// 	userEmail: string
// 	drive: driveV3.Drive
// }) {
// 	const result = await drive.permissions.create({
// 		fileId,
// 		sendNotificationEmail: false,
// 		requestBody: {role: 'reader', type: 'user', emailAddress: userEmail},
// 	})

// 	console.log(result.data)
// }

// export async function generateMasterPdf({
// 	documentsIds,
// 	fileName,
// 	targetFolderId,
// }: {
// 	documentsIds: string[]
// 	fileName: string
// 	targetFolderId: string
// }) {}

export function replaceTemplatesInFileName({
	fileName,
	values,
}: {
	fileName: string
	values: {[key: string]: {value: string}}
}) {
	let newFileName = fileName

	for (const valueName of Object.keys(values)) {
		newFileName = newFileName.replace(
			`{{${valueName}}}`,
			values[valueName].value
		)
	}

	return newFileName
}

export async function sendPriceAlertIfLimitExceeded({
	values,
	blueprint,
	customerInfo,
}: {
	blueprint: {id: string; userName: string; name: string}
	values: {[key: string]: string}
	customerInfo: CustomerInfo
}) {
	if (!customerInfo.priceLimit) return

	if (
		Number(values[customerInfo.priceLimit.fieldName]) >=
		customerInfo.priceLimit.limit
	) {
		console.log('Sending email', blueprint, customerInfo.priceLimit.alertEmail)
		await sendMail({
			to: customerInfo.priceLimit.alertEmail,
			subject: 'Fillo App - Document with exceeding price was generated',
			html: `
				<p>New document named: <b>${blueprint.name}</b> with exceeding price was generated by <b>${blueprint.userName}</b></p>
			`,
		})
	}
}
