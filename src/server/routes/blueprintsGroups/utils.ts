import {PoolClient} from 'pg'
import {drive_v3 as driveV3, docs_v1 as docsV1, google} from 'googleapis'
import {Stream} from 'stream'
import unique from 'array-unique'
import {CustomerInfo} from '../../../constants/models/customerInfo'
import {Blueprint} from '../../../constants/models/Blueprint'
import sendMail from '../../utils/sendMail'
import {getOAuth2Client} from '../../utils/googleApis'
import {getDataForSpreadsheetExport} from './db'

// const TEMP_FOLDER: string = String(process.env.TEMP_FOLDER)

export interface Tokens {
	accessToken?: string
	refreshToken?: string
}

async function copyFile({
	sourceId,
	name,
	targetFolderId,
	drive,
}: {
	sourceId: string
	name: string
	targetFolderId: string
	drive: driveV3.Drive
}): Promise<string> {
	const result = await drive.files.copy({
		fileId: sourceId,
		requestBody: {
			name,
			parents: [targetFolderId],
		},
	})

	return result.data.id || '0'
}

export async function canUserRead({
	fileId,
	drive,
}: {
	fileId: string
	drive: driveV3.Drive
}): Promise<boolean> {
	try {
		await drive.files.get({fileId})
		return true
	} catch (e) {
		return false
	}
}

async function replaceTemplateStrings({
	documentId,
	keyMap,
	docs,
}: {
	documentId: string
	keyMap: any
	docs: docsV1.Docs
}) {
	const replaceTextRequests = Object.keys(keyMap).map((key) => {
		return {
			replaceAllText: {
				containsText: {text: `{{${key}}}`, matchCase: true},
				replaceText: keyMap[key],
			},
		}
	})

	await docs.documents.batchUpdate({
		documentId,
		requestBody: {
			requests: replaceTextRequests,
		},
	})
}

export async function generateFilledDocument({
	blueprint,
	targetFolderId,
	fileName,
	values,
	drive,
	docs,
}: {
	blueprint: Blueprint
	fileName: string
	values: any
	targetFolderId: string
	drive: driveV3.Drive
	docs: docsV1.Docs
}): Promise<string> {
	const createdFileId = await copyFile({
		drive,
		name: fileName,
		sourceId: blueprint.googleDocsId,
		targetFolderId,
	})

	await replaceTemplateStrings({
		documentId: createdFileId,
		docs,
		keyMap: values,
	})

	return createdFileId
}

export async function saveDocumentAsPdf({
	name,
	fileId,
	folderId,
	drive,
}: {
	name: string
	fileId: string
	folderId: string
	drive: driveV3.Drive
}): Promise<string> {
	const exportResponse = await drive.files.export(
		{
			fileId,
			mimeType: 'application/pdf',
		},
		{
			responseType: 'stream',
		}
	)
	// @ts-ignore
	const outputStream: Stream = exportResponse.data

	const creatResponse = await drive.files.create({
		media: {
			mimeType: 'application/pdf',
			body: outputStream,
		},
		requestBody: {
			name,
			mimeType: 'application/pdf',
			parents: [folderId],
		},
	})

	return creatResponse.data.id || '0'
}

export async function getFolderInfo({
	folderId,
	drive,
}: {
	folderId: string
	drive: driveV3.Drive
}) {
	try {
		const exportResponse = await drive.files.get({
			fileId: folderId,
		})
		const {id, name} = exportResponse.data
		return {id, name}
	} catch (e) {
		return null
	}
}

export async function silentlyDeleteFile({
	fileId,
	drive,
}: {
	fileId: string
	drive: driveV3.Drive
}) {
	console.log('removing file', {fileId})
	try {
		await drive.files.delete({
			fileId,
		})
	} catch (e) {
		// Fail silently
	}
}

// export async function shareWithUser({
// 	fileId,
// 	userEmail,
// 	drive,
// }: {
// 	fileId: string
// 	userEmail: string
// 	drive: driveV3.Drive
// }) {
// 	const result = await drive.permissions.create({
// 		fileId,
// 		sendNotificationEmail: false,
// 		requestBody: {role: 'reader', type: 'user', emailAddress: userEmail},
// 	})

// 	console.log(result.data)
// }

// export async function generateMasterPdf({
// 	documentsIds,
// 	fileName,
// 	targetFolderId,
// }: {
// 	documentsIds: string[]
// 	fileName: string
// 	targetFolderId: string
// }) {}

export function replaceTemplatesInFileName({
	fileName,
	values,
}: {
	fileName: string
	values: {[key: string]: {value: string}}
}) {
	let newFileName = fileName

	for (const valueName of Object.keys(values)) {
		newFileName = newFileName.replace(
			`{{${valueName}}}`,
			values[valueName].value
		)
	}

	return newFileName
}

export async function sendPriceAlertIfLimitExceeded({
	values,
	blueprint,
	customerInfo,
}: {
	blueprint: {id: string; userName: string; name: string}
	values: {[key: string]: string}
	customerInfo: CustomerInfo
}) {
	if (!customerInfo.priceLimit) return

	if (
		Number(values[customerInfo.priceLimit.fieldName]) >=
		customerInfo.priceLimit.limit
	) {
		console.log('Sending email', blueprint, customerInfo.priceLimit.alertEmail)
		await sendMail({
			to: customerInfo.priceLimit.alertEmail,
			subject: 'Fillo App - Document with exceeding price was generated',
			html: `
				<p>New document named: <b>${blueprint.name}</b> with exceeding price was generated by <b>${blueprint.userName}</b></p>
			`,
		})
	}
}

export async function exportToSpreadsheet({
	dbClient,
	refreshTokenOfWriter,
	customerId,
	sheetId,
}: {
	dbClient: PoolClient
	customerId: string
	refreshTokenOfWriter: string
	sheetId: string
}) {
	const submits = await getDataForSpreadsheetExport({
		customerId,
		dbClient,
	})

	const auth = getOAuth2Client({
		refreshToken: refreshTokenOfWriter,
	})

	const sheets = google.sheets({version: 'v4', auth})

	const allFields = [
		...unique(
			submits
				.map((one) => one.fields)
				.reduce((curr, one) => [...curr, ...one], [])
				.sort()
		),
	]

	const values = [
		['name', 'submittedAt', 'submittedBy', ...allFields],
		...submits.map((oneSubmit) => {
			return [
				oneSubmit.name || '',
				oneSubmit.submittedAt || '',
				oneSubmit.submittedBy || '',
				...allFields.map(
					(fieldName) =>
						oneSubmit.values.find((one: any) => one.name === fieldName)
							?.value || ''
				),
			]
		}),
	]

	console.log(values)
	const resource = {values}

	// await sheets.spreadsheets.batchUpdate({
	// 	spreadsheetId: sheetId,
	// 	fields: '*',
	// })

	await sheets.spreadsheets.values.clear({
		spreadsheetId: sheetId,
		range: 'Sheet1',
	})

	// @ts-ignore
	await sheets.spreadsheets.values.update({
		spreadsheetId: sheetId,
		range: 'Sheet1!A1',
		valueInputOption: 'RAW',
		resource,
	})

	// @ts-ignore
	await sheets.spreadsheets.batchUpdate({
		spreadsheetId: sheetId,
		requestBody: {
			requests: [
				{
					'autoResizeDimensions': {
						'dimensions': {
							'dimension': 'COLUMNS',
						},
					},
				},
			],
		},
	})

	return values
}
